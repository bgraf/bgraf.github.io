<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>TSP subtour elimination II - User Cut Callbacks | bg</title>
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/css/fonts.css" />
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: '\\[', right: '\\]', display: true },   
                { left: '$$', right: '$$', display: true },     
                { left: '\\(', right: '\\)', display: false },  
            ],
            throwOnError: false
        });
    });
</script>
  

</head>

<body>
  <header>
    <div style="display:flex; flex-direction: row; gap:30px">
      <div>
        
        <a href="/">
          <img src="/logo3.svg" alt="bg">
        </a>
      </div>
      <div style="align-self:flex-end; margin-bottom: 15px;">
        <nav style="display:flex; flex-direction: row; align-items: flex-start; gap:10px;">
            <a title="Pages" href="/links">
              Pages
            </a>
            <a title="Posts" href="/posts/">
              Posts
            </a>
            <a title="RSS feed" href="/index.xml">
              RSS
            </a>
          <hr />
        </nav>
      </div>
    </div>

  </header>
<div class="article-meta">
<h1><span class="title">TSP subtour elimination II - User Cut Callbacks</span></h1>

<h2 class="date">2024-10-29</h2>

    <div class="tags">
    
        <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
    
        <a href="/tags/ortools">ortools</a>
    
        <a href="/tags/mathopt">mathopt</a>
    
        <a href="/tags/optimization">optimization</a>
    
        <a href="/tags/tsp">TSP</a>
    
    </div>

</div>



<main>
<p><a href="https://bgraf.github.io/posts/ortools-lazy-constraint-callbacks-tsp/">In an earlier post</a> I demoed the lazy constraint callback of ORTools&rsquo; <code>math_opt</code> module
to generate subtour elimination constraints for the TSP.
Coded in Python the process to solve a single instance took around 65 seconds. I wondered what the runtime of the same algorithm and instance would be if instead of python,
we&rsquo;d use the C++ ORTools library. In the next few paragraphs we will reduce the runtime from 65 to 12 seconds by using</p>
<ol>
<li>C++ and</li>
<li>user cuts to tighten the LP relaxation.</li>
</ol>
<h2 id="reimplementation-in-c">Reimplementation in C++</h2>
<p>The reimplementation of the model and the lazy constraint callback in C++ is a straightforward translation of the Python model.
<a href="https://github.com/bgraf/code-examples/blob/a4bec705833b52bed940cf6ca650d9537022642d/user_cut_subtour_elimination/tsp_bc.cc">The full code can be found here</a>.
Again we&rsquo;re using the bundled MIP-solved SCIP.</p>
<p>The API of the Python and C++ modules are more or less the same, except for some strange mixture of <code>CamelCase</code> and <code>snake_case</code> in the C++ API.</p>
<p><strong>Results</strong>: it takes around 47 seconds to reach the optimal solution.</p>
<p>We save 27 % of the processing time by switching from Python to C++.
Some improvement was to be expected as there is less de-/serialization between the C++ libary and the Python wrappers and types.</p>
<h3 id="what-happens-if-we-warm-start-with-the-optimal-tour">What happens if we warm start with the optimal tour?</h3>
<p>We already know the optimal solution for the problem, so let&rsquo;s provide it to the solver as <em>warm start</em> or <em>solution hint</em> in ORTools terminology.
Given the optimal tour we encode it in terms of MIP variables: all variables associated with edges of the optimal tour are assigned <code>1</code>, all remaining variables are assigned <code>0</code>.</p>
<p><strong>Results</strong>: it takes around 7.5 seconds to <em>prove</em> optimality.</p>
<h2 id="lazy-constraints-vs-user-cuts">Lazy Constraints vs. User Cuts</h2>
<p>Before we shave off a few more seconds from the 47 seconds of the processing time without needing a priori knowledge about the optimal tour, let&rsquo;s discuss the difference between the lazy constraint callsbacks we used up to now and the user cut callback we&rsquo;re going to use.</p>
<p>A lazy constraint callback adds constraints to a partial model such that at some point a feasible integer solution of the partial model is also an integer feasible solution of the real model.
In other words the lazy constraints eliminate integer solutions that are only feasible for the partial model, but not for the real model.
In case of the TSP the lazy constraint callback finds and adds violated subtour elimination constraints until a solution with a single tour is found.
Therefore if we start with a partial model, <strong>a lazy constraint callback is required to find a solution</strong> for the real model.</p>
<p>A user cut callback adds constraints to an LP relaxation to improve the bounds during the branch-and-bound process.
Assuming a minimization problem, subtrees in the branch-and-bound tree can be ignored if their lower bound is greater or equal to the current best integer feasible solution.
The lower bound is given by the optimal solution of the LP relexation of the node, i.e., the optimal solution to the problem while ignoring any integrality constraints on the variables.
The goal of a user cut callback is to improve the lower bound (or upper bound for maximization problem) to prune the branch-and-bound tree faster.
Therefore <strong>a user cut callback is never required</strong>, but it helps to speed up the process of proving optimality.</p>
<h2 id="cutting-planes">Cutting Planes</h2>
<p>Cutting planes are derived from <em>valid inequalities</em>.
A valid inequality is a set of constraints, such that for all integer feasible solutions, any inequality from the set is always true.
Besides this necessary condition, a good valid inequality also reduces the size of the LP relaxation&rsquo;s feasible region
to improve the lower bound.</p>
<figure><img src="/posts/tsp-user-cuts/cuttingplane.png"
    alt="Cutting plane" width="100%"><figcaption>
      <p>Cutting plane</p>
    </figcaption>
</figure>

<p>In the figure above the LP relaxations feasible region is limited by the blue lines indicating.
The cutting plane (orange) reduces the size of the LP feasible region without eliminating any integer feasible solutions.</p>
<h2 id="subtour-elimination-cutting-planes">Subtour Elimination Cutting Planes</h2>
<p>The implementation of the <a href="https://bgraf.github.io/posts/ortools-lazy-constraint-callbacks-tsp/">lazy constraint callback</a> to find invalid
subtour elimination constraints in integer solutions was rather simple:
collect all tours from the solution; if there are two or more, add a constraint to force flow between a tour and all other nodes.</p>
<p>A user cut callback is working on a solution to an LP relaxation.
The resulting graph may be a single connected component but not a single tour like in the figure below.</p>
<figure><img src="/posts/tsp-user-cuts/mincut.png"
    alt="Example LP solution with a single connected component" width="70%"><figcaption>
      <p>Example LP solution with a single connected component</p>
    </figcaption>
</figure>

<p>We can still use the idea that a valid tour always has a flow of two between any non-empty set of nodes
and its complement with respect to the total node set.
We therefore need to look at the <em>minimum cuts</em> for all pairs of nodes.
If we find a cut smaller than two, we can add a subtour elimination constraint.</p>
<p>To find all the relevant minimum cuts a <a href="https://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree">Gomory-Hu tree</a> can be used.
For my code I used the <a href="http://lemon.cs.elte.hu/pub/doc/1.3.1/index.html">LEMON</a> graph library implementation.</p>
<p><strong>Results</strong>: it takes around 12 seconds to reach the optimal solution.</p>
<h2 id="summary">Summary</h2>
<p>Using a user cut callback to tighten the LP relaxation with subtour elimination constraints (and using C++) reduced
the overall time required to solve our example instance by 81 %.
While user cut callbacks are never required to reach a feasible optimal solution, they can improve the speed significantly.</p>

</main>

  <footer>
  
  
  </footer>
  </body>
</html>

