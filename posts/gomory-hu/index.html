<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gomory-Hu Trees and Gusfield&#39;s algorithm | bg</title>
  <link rel="stylesheet" href="/css/style.css" />
  <link rel="stylesheet" href="/css/fonts.css" />
  

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: '\\[', right: '\\]', display: true },   
                { left: '$$', right: '$$', display: true },     
                { left: '\\(', right: '\\)', display: false },  
            ],
            throwOnError: false
        });
    });
</script>
  

</head>

<body>
  <header>
    <div style="display:flex; flex-direction: row; gap:30px">
      <div>
        
        <a href="/">
          <img src="/logo3.svg" alt="bg">
        </a>
      </div>
      <div style="align-self:flex-end; margin-bottom: 15px;">
        <nav style="display:flex; flex-direction: row; align-items: flex-start; gap:10px;">
            <a title="Pages" href="/links">
              Pages
            </a>
            <a title="Posts" href="/posts/">
              Posts
            </a>
            <a title="RSS feed" href="/index.xml">
              RSS
            </a>
          <hr />
        </nav>
      </div>
    </div>

  </header>
<div class="article-meta">
<h1><span class="title">Gomory-Hu Trees and Gusfield&rsquo;s algorithm</span></h1>

<h2 class="date">2025-03-23</h2>

    <div class="tags">
    
        <a href="/tags/graphs">graphs</a>
    
        <a href="/tags/algorithms">algorithms</a>
    
    </div>

</div>



<main>
<p>When I need to calculate all minimum \(s\)-\(t\) cuts in an undirected (and possibly weighted) graph
(<a href="https://bgraf.github.io/posts/tsp-user-cuts/">for example to implement TSP cuts</a>) I used
<a href="https://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree">Gomory-Hu Trees</a>.
I never looked at the actual algorithm, so here are some properties of Gomory-Hu trees and the commented algorithm
in python for future reference.</p>
<h2 id="what-is-a-gomory-hu-tree">What is a Gomory-Hu tree?</h2>
<p>Given an undirected connected graph \(G\) with edge capacities, a Gomory-Hu tree \(T\)</p>
<ul>
<li>Has the same vertex set as \(G\).</li>
<li>Has weighted edges which are unrelated to the edges of \(G\).</li>
<li>Isn&rsquo;t unique: there could be multiple distinct trees to represent the same information.
Multiple distinct trees indicate multiple distinct minimum cuts.</li>
<li>Isn&rsquo;t rooted or can be rooted at any node.</li>
<li>The tree represents all minimum \(s\)-\(t\) cuts of \(G\).
For any two nodes \(s, t \in V(G)\) let \(e\) be the minimum weight edge on the unique path between \(s\) and \(t\) in \(T\).
Then the weight of \(e\) corresponds to the maximum flow between \(s\) and \(t\) and the two connected components of \(T\) generated by
removing edge \(e\) correspond the minimum cut, i.e., the source and the sink side node sets.</li>
</ul>
<p><strong>Illustration</strong>:
The tree is like a set of islands connected by bridges.
The smallest bridge on any path determines the maximum size of a vehicle to make the trip.
<figure><img src="/posts/gomory-hu/bridges.png">
</figure>
</p>
<h2 id="gusfields-algorithm-to-derive-a-gomory-hu-tree">Gusfield&rsquo;s algorithm to derive a Gomory-Hu tree</h2>
<p>All relevant algorithms to derive a Gomory-Hu tree use \(|V(G) - 1|\) minimum cut calculations.
The original algorithm by Gomory and Hu works by contracting node subsets which reduces the size of the
graphs for the minimum cut calculations but incurs additional bookkeeping overhead for the contractions.
In contrast, Gusfield&rsquo;s algorithm works without contractions and is therefore easier to implement.</p>

<div class="highlight" style="position: relative;">
    
    <a class="highlight-url" href="https://github.com/bgraf/code-examples/blob/main/min-cut/gomory-hu.py">src</a>
    
    <pre class="chroma"
        tabindex="0"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gusfields_cut_tree</span><span class="p">(</span><span class="n">G</span><span class="p">:</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># == Initialization ==</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># Choose an arbitary root node</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># pred[n] is the parent of n in T.</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># The root doesn&#39;t have a parent, all other nodes are children of root.</span>
</span></span><span class="line"><span class="cl">    <span class="n">pred</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">pred</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># weight[n] is the weight of edge { n, parent(n) } in T.</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># The root doesn&#39;t have a weight, all other nodes have zero weight initially.</span>
</span></span><span class="line"><span class="cl">    <span class="n">weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">weight</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1"># == Calculation ==</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># Minimum cut between n and parent(n)</span>
</span></span><span class="line"><span class="cl">        <span class="n">pn</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">cut_value</span><span class="p">,</span> <span class="p">(</span><span class="n">source_side</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">pn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">weight</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_value</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># All siblings of n on n&#39;s side of the cut will become n&#39;s children.</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># The remaining siblings stay with parent(n).</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">source_side</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">nn</span> <span class="o">!=</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">pred</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">==</span> <span class="n">pn</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">pred</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1"># If n&#39;s grandparent is actually on n&#39;s side of the cut, n and its parent</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># swap places.        </span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">pred</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pred</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span> <span class="ow">in</span> <span class="n">source_side</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">pred</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">pred</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">weight</span><span class="p">[</span><span class="n">pn</span><span class="p">]</span> <span class="o">=</span> <span class="n">cut_value</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">    <span class="c1"># == Result ==</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pred</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">T</span></span></span></code></pre>
</div>
</main>

  <footer>
  
  
  </footer>
  </body>
</html>

